initSidebarItems({"constant":[["AT_FDCWD","sys_open 时的参数，表示在当前目录下"],["CPU_ID_LIMIT","指定一个特定的 cpu，用于执行启动过程中只能进行一次的初始化过程 最大的cpu_id再+1，可以认为是总的核数(无论是否使用)。目前在 virt 下是 4，在 sifive 下是 5"],["DEVICE_END","设备映射到内存的最后位置"],["DEVICE_START","设备(sdcard)映射到内存的起始位置"],["ELF_BASE_RELOCATE","如果 elf 的 phdr 指示 base 是 0(如 libc-test 的 libc.so)，则需要找一个非0的位置放置"],["FD_LIMIT_ORIGIN","预设的文件描述符数量限制"],["FIRST_CPU_ID","编号最小的可用的 cpu_id"],["FS_IMG_SIZE","文件系统镜像大小。只有这个常量可以被其他文件使用，而上面两个不能"],["IS_PRELOADED_FS_IMG","测试环境下，文件系统镜像是否是由qemu引入"],["IS_SINGLE_CORE","是否单核运行。单核运行时，则其他核只启动，不运行用户程序"],["IS_TEST_ENV","是否是比赛评测。线上评测时要求OS像一个批处理系统一样工作，这可能导致内核不会直接去拿初始进程并运行"],["KERNEL_HEAP_SIZE","内核堆的大小"],["KERNEL_STACK_SIZE","内核栈大小"],["LAST_CPU_ID","最后一个 CPU 的编号"],["LOCAL_FS_IMG_SIZE","文件系统镜像的大小。注意这个量和 fs-init 模块中 `/src/main.rs` 里生成镜像时的大小相同。 启动时会从 .data 段加载加载"],["LOG_LEVEL","运行时有多少内核输出"],["MMIO_REGIONS","用于设备 MMIO 的内存段。这些地址会在页表中做恒等映射"],["NO_PARENT","无父进程"],["ORIGIN_USER_PROC_NAME","入口用户程序。OS启动后，只会启动以此为名的用户程序。 一般来说，这个程序会通过 fork / exec 启动终端和其他程序"],["PAGE_SIZE","页表中每页的大小"],["PAGE_SIZE_BITS","即 log2(PAGE_SIZE)"],["PHYS_MEMORY_END","表示内存的地址段到此为止"],["PHYS_MEMORY_OFFSET","表示内存的地址段由此开始"],["PHYS_VIRT_OFFSET","内核中虚拟地址相对于物理地址的偏移"],["PIPE_SIZE_LIMIT","sys_pipe创建的管道的大小，单位为字节"],["REPORT_PAGE_FAULT","是否输出访存报错信息。这个信息会干扰到评测判定(换行问题)，但平时很有用"],["ROOT_DIR","文件系统的根目录，注意斜杠方向"],["SENDFILE_BUFFER_SIZE","sys_sendfile64 中使用 buffer 的大小"],["SIGNAL_RETURN_TRAP","一个在 Sv39 页表里不合法的地址。"],["SIGSET_SIZE_IN_BIT","所有可能的信号数。有多少可能的信号，内核就要为其保存多少个 SigAction"],["SIGSET_SIZE_IN_BYTE","signal 中用到的 bitset 长度。"],["SOCKET_BUFFER_SIZE_LIMIT","socket 使用的 buffer 大小"],["SPIN_LOOP_AFTER_BOOT","是否在启动后暂停。如果为 true，则所有核都只启动，不进入用户程序"],["TEST_FS_IMG_SIZE","测试时的文件系统镜像大小。 注意因为这个文件太大，默认是已经被qemu加载好了，启动时不会加载"],["TID_LIMIT","最小的 tid(进程号) 是 0，最大的 pid 是 TID_LIMIT-1"],["TMP_SIZE_LIMIT","临时文件的大小限制"],["USER_INIT_STACK_SIZE","初始用户栈大小，用于存放 argc/argv/envs/auxv"],["USER_STACK_OFFSET","用户栈底位置。同时也是最开始的用户堆顶位置"],["USER_STACK_RED_ZONE","SIGINFO 要求把一些信息存在用户栈上，从用户栈开辟一块空间来保存它们"],["USER_STACK_SIZE","用户栈大小"],["USER_VIRT_ADDR_LIMIT","用户地址最大不能超过这个值"],["USE_MSYNC","标记是否使用 msync。不做实际的检查效率更高， 但如果它影响了用户程序的正确性，需要还是打开的"]],"struct":[["AddrArea","一段左闭右开的地址区间，.0 为左端点， .1 为右端点，"]]});